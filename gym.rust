// main.rs - A simple command-line gym tracking application in Rust.

use std::io::{self, Write}; // Import necessary modules for input/output.
use std::collections::HashMap; // For storing exercises within a workout.

// Define a struct to represent a single set within an exercise.
#[derive(Debug, Clone)]
struct Set {
    reps: u32,    // Number of repetitions.
use std::io::{self, Write}; // Import necessary modules for input/output

// Define a struct to represent a gym member
#[derive(Debug, Clone)] // Derive Debug for easy printing, Clone to allow copying
struct Member {
    id: u32,
    name: String,
    age: u8,
    membership_type: String,
}

// Implement methods for the Member struct
impl Member {
    // Constructor for creating a new Member
    fn new(id: u32, name: String, age: u8, membership_type: String) -> Member {
        Member {
            id,
            name,
            age,
            membership_type,
        }
    }

    // Method to display member information
    fn display_info(&self) {
        println!("  ID: {}", self.id);
        println!("  Name: {}", self.name);
        println!("  Age: {}", self.age);
        println!("  Membership Type: {}", self.membership_type);
    }
}

// Define a struct to represent a gym check-in
#[derive(Debug, Clone)]
struct CheckIn {
    member_id: u32,
    timestamp: String, // Store as String for simplicity (e.g., "YYYY-MM-DD HH:MM:SS")
}

// Implement methods for the CheckIn struct
impl CheckIn {
    // Constructor for creating a new CheckIn
    fn new(member_id: u32, timestamp: String) -> CheckIn {
        CheckIn {
            member_id,
            timestamp,
        }
    }

    // Method to display check-in information
    fn display_info(&self) {
        println!("  Member ID: {}", self.member_id);
        println!("  Timestamp: {}", self.timestamp);
    }
}

// Function to get string input from the user
fn get_input(prompt: &str) -> String {
    print!("{}", prompt);
    io::stdout().flush().unwrap(); // Ensure the prompt is displayed immediately
    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("Failed to read line");
    input.trim().to_string() // Remove leading/trailing whitespace and return
}

// Function to get numeric input from the user (u32)
fn get_numeric_input(prompt: &str) -> u32 {
    loop {
        let input = get_input(prompt);
        match input.parse::<u32>() {
            Ok(num) => return num,
            Err(_) => println!("Invalid input. Please enter a number."),
        }
    }
}

// Function to get byte input from the user (u8)
fn get_byte_input(prompt: &str) -> u8 {
    loop {
        let input = get_input(prompt);
        match input.parse::<u8>() {
            Ok(num) => return num,
            Err(_) => println!("Invalid input. Please enter a number between 0 and 255."),
        }
    }
}

// Main application logic
fn main() {
    let mut members: Vec<Member> = Vec::new(); // Vector to store gym members
    let mut check_ins: Vec<CheckIn> = Vec::new(); // Vector to store check-in records
    let mut next_member_id: u32 = 1; // Counter for unique member IDs

    println!("Welcome to the Gym Management System!");

    loop {
        println!("\n--- Main Menu ---");
        println!("1. Add New Member");
        println!("2. Record Member Check-in");
        println!("3. View All Members");
        println!("4. View Member Details (by ID)");
        println!("5. View All Check-ins");
        println!("6. Exit");

        let choice = get_numeric_input("Enter your choice: ");

        match choice {
            1 => {
                // Add New Member
                println!("\n--- Add New Member ---");
                let name = get_input("Enter member name: ");
                let age = get_byte_input("Enter member age: ");
                let membership_type = get_input("Enter membership type (e.g., 'Monthly', 'Annual'): ");

                let new_member = Member::new(next_member_id, name, age, membership_type);
                members.push(new_member);
                println!("Member '{}' (ID: {}) added successfully!", members.last().unwrap().name, next_member_id);
                next_member_id += 1;
            }
            2 => {
                // Record Member Check-in
                println!("\n--- Record Member Check-in ---");
                if members.is_empty() {
                    println!("No members registered yet. Please add a member first.");
                    continue;
                }
                let member_id = get_numeric_input("Enter member ID for check-in: ");

                // Find the member by ID
                if let Some(member) = members.iter().find(|m| m.id == member_id) {
                    let current_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
                    let new_check_in = CheckIn::new(member.id, current_time);
                    check_ins.push(new_check_in);
                    println!("Member '{}' (ID: {}) checked in successfully at {}!", member.name, member.id, check_ins.last().unwrap().timestamp);
                } else {
                    println!("Member with ID {} not found.", member_id);
                }
            }
            3 => {
                // View All Members
                println!("\n--- All Members ---");
                if members.is_empty() {
                    println!("No members registered.");
                } else {
                    for member in &members {
                        member.display_info();
                        println!("--------------------");
                    }
                }
            }
            4 => {
                // View Member Details by ID
                println!("\n--- View Member Details ---");
                if members.is_empty() {
                    println!("No members registered yet.");
                    continue;
                }
                let member_id = get_numeric_input("Enter member ID to view details: ");

                if let Some(member) = members.iter().find(|m| m.id == member_id) {
                    println!("Details for Member ID {}:", member_id);
                    member.display_info();
                } else {
                    println!("Member with ID {} not found.", member_id);
                }
            }
            5 => {
                // View All Check-ins
                println!("\n--- All Check-ins ---");
                if check_ins.is_empty() {
                    println!("No check-in records found.");
                } else {
                    for check_in in &check_ins {
                        check_in.display_info();
                        println!("--------------------");
                    }
                }
            }
            6 => {
                // Exit
                println!("Exiting Gym Management System. Goodbye!");
                break; // Exit the loop
            }
            _ => {
                // Invalid choice
                println!("Invalid choice. Please enter a number between 1 and 6.");
            }
        }
    }
}
    weight: f64,  // Weight lifted (e.g., in kg or lbs).
}

// Define a struct to represent an exercise.
#[derive(Debug, Clone)]
struct Exercise {
    name: String,             // Name of the exercise (e.g., "Bench Press").
    sets: Vec<Set>,           // A list of sets performed for this exercise.
}

// Define a struct to represent a complete workout session.
#[derive(Debug, Clone)]
struct Workout {
    date: String,             // Date of the workout (e.g., "2023-10-27").
    // Using a HashMap to store exercises by their name for easy lookup and uniqueness.
    exercises: HashMap<String, Exercise>,
}

// Function to get user input as a String.
fn get_input(prompt: &str) -> String {
    print!("{}", prompt); // Display the prompt to the user.
    io::stdout().flush().expect("Failed to flush stdout"); // Ensure prompt is displayed immediately.

    let mut input = String::new(); // Create a mutable String to store input.
    io::stdin().read_line(&mut input).expect("Failed to read line"); // Read a line from stdin.
    input.trim().to_string() // Trim whitespace and convert to String.
}

// Function to get a u32 (unsigned 32-bit integer) from user input.
fn get_u32_input(prompt: &str) -> u32 {
    loop { // Loop until valid input is received.
        let input_str = get_input(prompt);
        match input_str.parse::<u32>() { // Attempt to parse the input as u32.
            Ok(num) => return num, // If successful, return the number.
            Err(_) => println!("Invalid input. Please enter a number."), // If parsing fails, print error.
        }
    }
}

// Function to get an f64 (64-bit floating-point number) from user input.
fn get_f64_input(prompt: &str) -> f64 {
    loop { // Loop until valid input is received.
        let input_str = get_input(prompt);
        match input_str.parse::<f64>() { // Attempt to parse the input as f64.
            Ok(num) => return num, // If successful, return the number.
            Err(_) => println!("Invalid input. Please enter a number."), // If parsing fails, print error.
        }
    }
}

// Function to add a new workout.
fn add_workout(workouts: &mut Vec<Workout>) {
    println!("\n--- Add New Workout ---");
    let date = get_input("Enter workout date (YYYY-MM-DD): ");
    let new_workout = Workout {
        date,
        exercises: HashMap::new(), // Start with no exercises.
    };
    workouts.push(new_workout); // Add the new workout to the list.
    println!("Workout added successfully!");
}

// Function to add an exercise to a specific workout.
fn add_exercise_to_workout(workouts: &mut Vec<Workout>) {
    if workouts.is_empty() {
        println!("No workouts available. Please add a workout first.");
        return;
    }

    println!("\n--- Add Exercise to Workout ---");
    // Display available workouts for selection.
    for (i, workout) in workouts.iter().enumerate() {
        println!("{}. Workout on {}", i + 1, workout.date);
    }

    let workout_index = get_u32_input("Select a workout by number: ") as usize;

    // Check if the selected index is valid.
    if workout_index == 0 || workout_index > workouts.len() {
        println!("Invalid workout selection.");
        return;
    }

    let workout = &mut workouts[workout_index - 1]; // Get mutable reference to the selected workout.
    let exercise_name = get_input("Enter exercise name: ");

    // Check if the exercise already exists in this workout.
    if workout.exercises.contains_key(&exercise_name) {
        println!("Exercise '{}' already exists in this workout.", exercise_name);
        return;
    }

    let new_exercise = Exercise {
        name: exercise_name.clone(),
        sets: Vec::new(), // Start with no sets.
    };

    // Insert the new exercise into the workout's HashMap.
    workout.exercises.insert(exercise_name, new_exercise);
    println!("Exercise added to workout successfully!");
}

// Function to log sets for an existing exercise within a workout.
fn log_sets_for_exercise(workouts: &mut Vec<Workout>) {
    if workouts.is_empty() {
        println!("No workouts available. Please add a workout first.");
        return;
    }

    println!("\n--- Log Sets for Exercise ---");
    // Display available workouts.
    for (i, workout) in workouts.iter().enumerate() {
        println!("{}. Workout on {}", i + 1, workout.date);
    }

    let workout_index = get_u32_input("Select a workout by number: ") as usize;

    if workout_index == 0 || workout_index > workouts.len() {
        println!("Invalid workout selection.");
        return;
    }

    let workout = &mut workouts[workout_index - 1];

    if workout.exercises.is_empty() {
        println!("No exercises in this workout. Please add an exercise first.");
        return;
    }

    // Display exercises in the selected workout.
    let mut exercise_names: Vec<&String> = workout.exercises.keys().collect();
    exercise_names.sort(); // Sort for consistent display.

    for (i, name) in exercise_names.iter().enumerate() {
        println!("{}. {}", i + 1, name);
    }

    let exercise_selection_str = get_input("Select an exercise by number: ");
    let exercise_selection = match exercise_selection_str.parse::<usize>() {
        Ok(num) => num,
        Err(_) => {
            println!("Invalid input. Please enter a number.");
            return;
        }
    };

    if exercise_selection == 0 || exercise_selection > exercise_names.len() {
        println!("Invalid exercise selection.");
        return;
    }

    let selected_exercise_name = exercise_names[exercise_selection - 1].clone();
    // Get mutable reference to the exercise.
    let exercise = workout.exercises.get_mut(&selected_exercise_name).unwrap();

    let num_sets = get_u32_input("How many sets do you want to log? ");

    for i in 0..num_sets {
        println!("--- Set {} ---", i + 1);
        let reps = get_u32_input("Enter reps: ");
        let weight = get_f64_input("Enter weight: ");
        exercise.sets.push(Set { reps, weight });
    }
    println!("Sets logged successfully for {}!", exercise.name);
}

// Function to view all recorded workouts and their details.
fn view_workouts(workouts: &Vec<Workout>) {
    if workouts.is_empty() {
        println!("\nNo workouts recorded yet.");
        return;
    }

    println!("\n--- Your Workouts ---");
    for (i, workout) in workouts.iter().enumerate() {
        println!("Workout {}: {}", i + 1, workout.date);
        if workout.exercises.is_empty() {
            println!("  No exercises recorded for this workout.");
        } else {
            for exercise in workout.exercises.values() {
                println!("  - Exercise: {}", exercise.name);
                if exercise.sets.is_empty() {
                    println!("    No sets logged for this exercise.");
                } else {
                    for (set_num, set) in exercise.sets.iter().enumerate() {
                        println!("    Set {}: {} reps @ {} kg/lbs", set_num + 1, set.reps, set.weight);
                    }
                }
            }
        }
        println!("--------------------");
    }
}

fn main() {
    let mut workouts: Vec<Workout> = Vec::new(); // A vector to store all workouts.

    loop { // Main application loop.
        println!("\nGym Tracker App");
        println!("1. Add New Workout");
        println!("2. Add Exercise to Workout");
        println!("3. Log Sets for Exercise");
        println!("4. View All Workouts");
        println!("5. Exit");

        let choice = get_input("Enter your choice: ");

        match choice.as_str() { // Match user input to available options.
            "1" => add_workout(&mut workouts),
            "2" => add_exercise_to_workout(&mut workouts),
            "3" => log_sets_for_exercise(&mut workouts),
            "4" => view_workouts(&workouts),
            "5" => {
                println!("Exiting Gym Tracker. Goodbye!");
                break; // Exit the loop and end the program.
            }
            _ => println!("Invalid choice. Please try again."), // Handle invalid input.
        }
    }
}
